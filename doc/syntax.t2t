Справка по синтаксису S-Lang
f0ma, f0ma@smtp.ru
v0.9.4

=Основные возможности языка=

В основе HardwareExport лежит скриптовый язык S-Lang. Это язык основанный на операциях со стеком (вызовах функций) со строгой динамической типизацией (тип переменной определяется при присвоении значения и не изменяется в дальнейшем).

= Переменные и функции =

S-Lang отличается от многих других интерпретируемых языков тем, что все переменные и функции должны быть объявлены перед использованием.

Основные операторы (`` + - ++ -- * / ``) аналогичны по синтаксису языку С. В S-Lang символ % используется, как признак начала комментария, все следующие за ним до конца строки символы игнорируются интерпритатором.

Переменные объявляются с использованием ключевого слова variable (в диалекте HWE можно использовать сокращение var). Например:
``` variable x, y, z;
или
``` var x, y, z;
объявляет три переменные, x, y, и z. Оператор ; ставится в конце выражения. Все выражения в S-Lang должны закачиваться ; .

В отличие от таких компилируемых языков как C, нет необходимости указывать тип данных переменной. Он будет определен автоматически при присвоении значения. Например после выполнения выражений
```
x = 3;
y = sin (5.6);
z = "I think, therefore I am.";
```
x получит тип integer, тип y будет double, а z - string. Также допустимо переприсвоение x значения, например типа string (однако этот прием не поощряется с точки зрения качества кода):
``` x = "x was an integer, but now is a string";

Возможно также объединение в одном выражении операторов объявления и присвоения:

``` variable x = 3, y = sin(5.6), z = "I think, therefore I am.";

Функции объявляются с помощью ключевого слова define (в диалекте HWE можно использовать сокращение def). Например, выражение:
``` 
define compute_average (x, y)
{
	variable s = x + y;
	return s / 2.0;
}
``` 
объявляет функцию, возвращающую среднее двух чисел. Этот пример показывает, что функция состоит из трех частей: имя функции, список параметров и тело функции.

Список параметров содержит имена параметров, разделенные запятыми. Нет необходимости повторно объявлять переменные из списка параметров, они объявляются автоматически. Естественно, все другие локальные переменные, использующиеся в функции, должны быть объявлены. Если функция не имеет параметров, список должен быть пустым:
``` 
define go_left_5 ()
{
	go_left (5);
}
``` 
Функция в последнем примере не принимает аргументов и не возвращает значение. В некоторых языках (например, в Pascal), такие конструкции носят название процедур. В S-Lang, как и в C, разницы между функциями и процедурами нет.

Язык допускает использование рекурсивных функций, т.е. функций вызывающих самих себя. Для этого в S-Lang функцию следует объявить заранее:

``` define function-name (); 

При этом не требуется указывать список параметров.

Возможно самый популярный (но не самый лучший прим. пер.) пример рекурсивной функции - вычисление факториала. Вот пример ее реализации на S-Lang:

``` 
define factorial ();   % declare it for recursion

define factorial (n)
{
	if (n < 2) return 1;
	return n * factorial (n - 1);
}
``` 
В этом примере также показано как можно вставлять в код комментарии. 

== Управляющие конструкции ==

Синтаксис управляющих конструкция в S-Lang в целом аналогичен языку C:

``` 
if(условие){...}
while(условие) {...}
do {...} while(условие) 
for(инициализация;условие;изменение) {...} 
``` 

Рассмотрим на примере печати 10 символов 'a' использование операторов цикла:

``` 
var a = 0;

while(a<10)
{
	print("a");
	a++;
}
``` 

``` 
var a = 0;

do
{
	print("a");
	a++;
}
while(a<10);
``` 

``` 
var a;

for(a=0;a<10;a++)
{
    print("a");
} 
``` 
Все эти три примера эквивалентны.

== Именованные параметры ==

В S-Lang 2.1 введена поддержка именованных параметров функция, как средства передачи в функцию дополнительной информации. Например, рассмотрим функцию построения графика:
``` 
define plot (x, y)
{
	variable linestyle = qualifier ("linestyle", "solid");
	variable color = qualifier ("color", "black");

	sys_set_color (color);
	sys_set_linestyle (linestyle);
	sys_plot (x,y);
}
``` 
Здесь sys_set_linestyle, sys_set_color, и sys_plot - гипотетические низкоуровневые функции, выполняющие непосредственные операции. Эта функция может быть вызвана следующим образом:
``` 
x = [0:10:0.1];
plot (x, sin(x));
``` 
для рисования непрерывной (solid) черной (black) линии соединяющей точки или
``` plot (x, sin(x); linestyle="dashed");
для рисования штрихованной линии (dashed) и соответственно
``` plot (x, sin(x); linestyle="dotted", color="blue");
для рисования синей (blue) линии точками (dotted).

== Сторки ==

Возможно, самой привлекательной функцией любого интерпретируемого языка является освобождение пользователя от ручного управления распределением памяти. Это заметно при сравнении того как S-Lang и С обрабатывает строки. Например, функция соединяющая строки на S-Lang выглядит следующим образом:
``` 
define concat_3_strings (a, b, c)
{
	return strcat (a, b, c);
}
``` 
Здесь используется встроенная функция strcat, соединяющая 2 и более строки. На C аналогичная функция будет выглядеть так:
``` 
char *concat_3_strings (char *a, char *b, char *c)
{
	unsigned int len;
	char *result;
	len = strlen (a) + strlen (b) + strlen (c);
	strcpy (result, a);
	strcat (result, b);
	strcat (result, c);
	return result;
}
``` 
Бинарные операторы объявлены и для типа данных string. Например, оператор + может быть использован для конкатенации строк. В этом случае он будет служить аналогом strcat:
``` 
define concat_3_strings (a, b, c)
{
	return a + b + c;
}
``` 

== Ссылки ==

Унарный оператор & может быть использован для создания ссылки на объект, которая аналогична указателю в других языках. Передача по ссылке широко используется для передачи в функцию в качестве аргумента другой функции:

``` 
define compute_functional_sum (funct)
{
	variable i, s;

	s = 0;
	for (i = 0; i < 10; i++)
	{
		s += (@funct)(i);
	}
	return s;
}

variable sin_sum = compute_functional_sum (&sin);
variable cos_sum = compute_functional_sum (&cos);
``` 

Здесь функция compute_functional_sum применяет функцию, указанную в качестве параметра funct, для получения ее значений от первых 10 целых чисел и  возвращает их сумму. Следующие два выражения демонстрируют использование данной функции в применении к синусу и косинусу.

Оператор @ используется в compute_functional_sum для разыменования. Он является обратным оператором по отношению к унарному &.

Вот еще один способ использования ссылок:
``` 
define read_nth_line (file, n)
{
	variable fp, line;
	fp = fopen (file, "r");

	while (n > 0)
	{
		if (-1 = fgets (&line, fp))
			return NULL;
		n--;
	}
	return line;
}
``` 
здесь функция fgets используется для чтения n-той строки файла. В частности, ссылка на локальную переменную line передается в fgets, таким образом, в переменной line оказывается строка прочитанная fgets.

И, наконец, использование ссылок может быть альтернативой возможности возвращать несколько переменных, как результат работы функции. В этом примере результат выполнения возвращается через параметры функции:
``` 
define set_xyz (x, y, z)
{
	@x = 1;
	@y = 2;
	@z = 3;
}
variable X, Y, Z;
set_xyz (&X, &Y, &Z);
``` 
после исполнения X будет равно 1, Y = 2, и Z = 3. Аналогичный пример на C выглядит следующим образом:
``` 
void set_xyz (int *x, int *y, int *z)
{
	*x = 1;
	*y = 2;
	*z = 3;
}
``` 

== Массивы ==

Язык S-Lang поддерживает многомерные массивы для всех типов данных. Например, могут быть созданы массивы ссылок на функции или массив массивов. Рассмотрим несколько примеров объявления массивов:
``` 
variable A = Int_Type [10];  
variable B = Int_Type [10, 3];
variable C = [1, 3, 5, 7, 9];
``` 
В первом примере создается массив из 10 целых чисел и присваивается переменной A. Во втором примере создается 2-х мерный массив из 30 целых чисел состоящий из 10 строк и 3 столбцов и присваивается переменной B. В последнем примере массив из 5 целых присваивается переменной C. В данном случае элементы массива инициализируются указанными значениями, а тип определяется автоматически.

S-Lang так же поддерживает технологию range-массивов. Например, следующее выражение
``` 
variable C = [1:9:2];
``` 
создает массив из 5 целых от 1 до 9 с шагом 2. Аналогично [0:1:#1000] обозначает массив из 1000 элементов с плавающей запятой в промежутке от 0 до 1 (включительно).

Массивы всегда передаются в функцию по ссылке и никогда по значению. Это позволяет создавать функции инициализирующие массивы, например:
``` 
define init_array (a)
{
	variable i, imax;

	imax = length (a);
	for (i = 0; i < imax; i++)
	{ 
		a[i] = 7;
	}
}

variable A = Int_Type [10];
init_array (A);
``` 
создает массив из 10 целых и инициализирует все его элементы значением 7.

Существуют более краткие способы выполнения этой операции, например:

``` 
A = [7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
A = Int_Type [10];  A[[0:9]] = 7;
A = Int_Type [10];  A[*] = 7;
``` 
Второй и третий метод используют массивы в качестве индексов элементов массива A. Во втором случае, диапазон индексов указывается непосредственно, а в третьем для определения всех элементов массива используется знак * .

Хотя предыдущие примеры относились к массивам из целых чисел, S-Lang может создавать массивы любых типов:
``` 
A = Double_Type [10];
B = Complex_Type [10];
C = String_Type [10];
D = Ref_Type [10];
``` 
создает массивы из 10 элементов тип double, complex, string, и ссылочного типа, соответственно. (в HWE существует тип массива ByteArray являющийся переопределением UChar_Type - байтов). Последний пример может быть использован для создания массивов функций:
``` 
D[0] = &sin;
D[1] = &cos;
``` 
В языке объявлены унарные и бинарные математические операции над массивами. К примеру, если A и B - массивы целых, A + B - массив в котором каждый элемент является суммой соответствующих элементов массивов A и B. Простейший пример, демонстрирующий эту возможность языка:
``` 
variable X, Y;
X = [0:2*PI:0.01];
Y = 20 * sin (X);
``` 
что эквивалентно коду на C:
``` 
double *X, *Y;
unsigned int i, n;

n = (2 * PI) / 0.01 + 1;
X = (double *) malloc (n * sizeof (double));
Y = (double *) malloc (n * sizeof (double));
for (i = 0; i < n; i++)
{
	X[i] = i * 0.01;
	Y[i] = 20 * sin (X[i]);
}
``` 

== Списки ==

Списки в S-Lang в отличие от массивов могут содержать данные различных типов например:
``` my_list = { 3, 2.9, "foo", &sin };
создает список из четырех объектов, различного типа. Как и в массивах, элементы списка доступны при помощи индекса:
``` x=my_list[2]
выполнит присвоение переменной x значения "foo". Основное отличие между массивами и списками в том, что размер массива является фиксированным, тогда как список может расти и сокращаться. Алгоритмы, требующие подобные операции выполняются со списками гораздо быстрее, чем с массивами.

== Структуры и типы данных определяемые пользователем ==

Существуют аналогичные массиву тип данных, который может быть использован как контейнер. Естественно, в отличие от массивов не требуется, чтобы все элементы имели один тип. Такой тип данных называется структурой:
``` 
variable person = struct 
{
	first_name, last_name, age
};
variable bill = @person;
bill.first_name = "Bill";
bill.last_name = "Clinton";
bill.age = 51;
``` 
В этом примере создаваемая структура содержит три поля и при создании присваивается переменной person. Для создания инстнса данной структуры, используется оператор разыменования. Новый инстанс присваивается переменной bill, после чего инициализируются отдельные поля.

S-Lang, начиная с версии, 2.1 позволяет создавать безыменные структуры данных
``` 
variable bill = struct
{
	first_name = "Bill", 
	last_name = "Clinton",
	age = 51
};
``` 
Также можно создать на основе структуры отдельный тип данных при помощи ключевого слова typedef:
``` 
typedef struct
{
	first_name, last_name, age
}
Person_Type;

variable bill = @Person_Type;
bill.first_name = "Bill";
bill.last_name = "Clinton";
bill.age = 51;
``` 
Это позволяет создавать массивы из структур:
``` 
People = Person_Type [100];
People[0].first_name = "Bill";
People[1].first_name = "Hillary";
``` 
аналогично можно создать массив переменных типа Struct_Type и в каждом из его элементов создать инстанс структуры вручную:
``` 
People = Struct_Type [100];
People[0] = @person;
People[0].first_name = "Bill";
People[1] = @person;
People[1].first_name = "Hillary";
``` 

Кроме того для пользовательских типов могут быть перегружены унарные и бинарные операторы.

Создание и инициализация структуры может быть произведено в функции:
``` 
define create_person (first, last, age)
{
	variable person = @Person_Type;
	person.first_name = first;
	person.last_name = last;
	person.age = age;
	return person;
}
variable Bill = create_person ("Bill", "Clinton", 51);
``` 

=Взаимодействие со средой HardwareExpert =

На уровне программы помимо вызовов API существует возможность запускать отдельные функции через GUI HWE.

=Экспорт функций скрипта=

Скрипты в HardwareExpert работают в 2 этапа: 
 
- компиляция (в байткод) 
- исполнение 

 
Во время компиляции (которая обычно происходит при загрузке скрипта или при нажатии на соответствующую кнопку) весь код скрипта, который не был убран у тела функций, немедленно исполняется. После компиляции отдельные, специальным образом объявленные функции могут быть вызваны через GUI.

Для этого применяется следующий синтаксис: 

``` 
defapi foo() : "Операция Foo"
{
bar(2,3);
bar(4,5);
print("OK!\n");
} 
``` 

После компиляции скрипта на панели Functions появится иконка с надписью Операция Foo. Теперь эту функцию можно вызвать, щелкнув дважды по иконке.

= Библиотека скриптов = 

Скрипты могут автоматически добавляться в библиотеку программы.

Для этого необходимо добавить в "Настройки" -> "Опции" -> "Каталог скриптов" путь к папке содержащей скрипты.

Все файлы с расширением *.slh в папках из этого списка будут прочитаны при запуске программы. Если они имеют загаловок (первую строку) соответствующего вида, то они будут включены в библиотеку.

Формат заголовка:

``` %ИмяКатегории \ ИмяСкрипта \ КраткоеOписание

Если первая строка документа начинается с символов ``%!``, то она игнорируется и как заголовок рассматривается вторая строка (для совместимости с UNIX scripting).

