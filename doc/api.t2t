Справка по API HardwareExport
f0ma, f0ma@smtp.ru
v0.9.4

%!postproc : '^#(\w+)' '<br/><a name="\1"></a>'

== Общее ==

#TRUE
Константа true. Эквивалента целому 1. Используется в функциях как аргумент типа BOOL.

#FALSE
Константа false. Эквивалента целому 0. Используется в функциях как аргумент типа BOOL.

#setBit
``` BYTE setBit (BYTE src,BYTE bit_number,BOOL value)
Возвращает байт ``src``, в котором бит ``bit_number`` установлен в значение ``value``.

#getbit
``` BOOL getBit (BYTE src,BYTE bit_number)
Возвращает значение бита ``bit_number`` в байте ``src``.

#wait
``` VOID wait (INT msec)
Ожидать ``msec`` микросекунд (следует учитывать, что из-за многозадачности задержки вызванные работой других процессов могут длиться до 1 мс и происходить в произвольном месте программы, поэтому для критичных по времени операций рекомендуется применять внешний активный адаптер).

== Массивы ==

Основной тип массивов с которыми работает среда, это ``UChar_Array`` или ``ByteArray`` (это два имени одного и того-же типа). Кроме того, все функции принимающие в качестве аргумента ``ByteArray`` могут также принимать ``INT_Array`` - формат числовых массивов SLang по умолчанию. Благодаря этому возможно использование следующих конструкций:
```
var arr = concat([1,2],[3,4]);
``` 
в результате ``arr = [1,2,3,4,5]``.

#copy
``` BYTEARRAY copy (BYTEARRAY arr)
Создает и возвращает новый массив, копию ``arr``.

#length
``` INT length (BYTEARRAY arr)
Возвращает длину массива.

#fill
```
BYTEARRAY fill (BYTEARRAY arr,BYTE value,INT start,INT len)
BYTEARRAY fill (BYTEARRAY arr,BYTE value,INT start)
BYTEARRAY fill (BYTEARRAY arr,BYTE value)
```
Возвращает новый массив, полученный из ``arr`` аполнением байтами ``value`` начиная с ``start``, длинной ``len``. При отсутствии рагумента ``start``, по умолчанию используется 0, при отсутствии аргумента ``len``, заполняется весь массив.

#concat
``` BYTEARRAY concat (BYTEARRAY a1,BYTEARRAY a2)
Возвращает новый массив состоящий из конкатинации массивов ``a1`` и ``a2``.

#fromInt
``` BYTEARRAY fromInt(INT value,INT width)
Возвращает новый массив байт, в котором содержится значение ``value``. Длина массива определяется параметром ``width``. Не знятые числом элементы массива заполняются нулями.

#fromHex
``` BYTEARRAY fromHex(STR value)
Превращает текстовую строку шестнадцатеричных цифр в массив.

#fromAscii
``` BYTEARRAY fromAscii(STR value)
Превращает ASCII строку в массив (каждому символу ставится в соответствие его код по таблице ASCII).

#subArray
``` BYTEARRAY subArray(BYTEARRAY arr,INT start,INT len)
Создает и возвращает новый массив, созданный из ``arr`` , начинающийся с позиции ``start`` длинной ``len``.

#toString
``` STR toString (BYTEARRAY arr)
Превращает массив ``arr`` в строку в соответствии с таблицей символов ASCII.

#load
``` BYTEARRAY load (STR filename)
Возвращает массив данных, загруженный из файла ``filename``. Файл ищется в папке скрипта. Если файл не найден возвращает массив нулевой длины.


== Hex редактор ==

#pageLoad
``` BYTEARRAY pageLoad()
Создает новый массив и загружает в него содержимое текущей страницы HexEditorа.

#pageOverwrite
``` VOID pageOverwrite (BYTEARRAY arr)
Перезаписывает текущую страницу HexEditorа массивом ``arr``.

#pageStore
``` VOID pageStore (BYTEARRAY arr, STRING name)

Создает новую страницу в HexEditorе c заголовком ``name`` и заполняет ее данными из массива ``arr``. Если страница с таким именем уже существует к имени добавляется суффикс.

#pageDelete
``` VOID deletePage ()

Удаляет текущую страницу из HexEditorа.

== Дополнительный файл конфигурации ==

Программа поддеживает работы с дополнительными файлами конфигурации. Файл должен иметь формат INI и лежать в той-же папке, что и скрипт. Перед началом работы с файлом вызывается функция ``configLoad`` загуржающая его в память интерпритатора.

#configLoad
``` VOID configLoad(STR filename)

Загружает файл ``filename`` в память интерпритатора.

#configValue
STR configValue(STR hkey,STR key)

Возвращает строку - значение ключа ``key`` в разделе ``hkey`` загруженного INI файла.

== Управление интрефейсом ==

=== Протокол ===

#print
``` VOID print (...)

Выводит в протокол список параметров. Формат вывода числовых данных определяется модификаторами: HEX,DEC,BIN. Например:
``` print("Data at ",DEC,i," ",array,"\n");
Формат по умолчанию - HEX. После применение модификатор снова сбрасыватся в HEX. Массивы BYTEARRAY определяются автоматически и печатуются соответствующим образом.

#clear
``` VOID clear ()
Очищает протокол.

#cr
``` VOID сr ()
Удаляет последнюю строку в протоколе.

=== Индикатор выполнения ===

#progvalue
``` VOID progValue (INT value)
Устанавливает индикатор прогресса в ``value``.

#progmax
``` VOID progMax (INT value)
Устанавливает максимальное значение индикатора прогресса в ``value`` (минимальное всегда 0).

#progwait
``` VOID progWait ()
Переводит индикатор прогресса в режим неопределенного ожидания.

#progclear
``` VOID progClear ()
Сбрасывает индикатор прогресса.

=== Середства диалога с пользователем ===

#quest
``` BOOL ask (STRING title,STRING text)
Задает пользователю вопрос вида Yes|No. На форме запроса имеется также кнопка прерывания выполнения.

В основе механизма опция лежит список пар (ключ => значение), называемый списком опций.

#optClear
``` VOID optClear ()
Очищает список опции.

#optOption
``` VOID optOption (STR name,STR txt, ? value, INT type)
Добаляет в список опцию с ключем ``name``. Эта опция будет в диалоге отображаться как ``txt``. Аргумент ``type`` отвечает  за тип поля и может принимать следующие значения:

OPT_LIST - будет добавлен выпадающей список. В аргументе ``value`` передается массив строк - значений. Значение с индексом 0 считается значением по умолчанию.

OPT_CHK - будет добавлен флажок. Аргумент ``value`` рассматривается как переменная типа BOOL и является значением опции по умолчанию.

OPT_DEC - будет добавлено поле для ввода числа в десятичной системе. Аргумент ``value`` рассматривается как переменная типа INT и является значением опции по умолчанию.

OPT_HEX - будет добавлено поле для ввода числа в шестнадцатеричной системе. Аргумент ``value`` рассматривается как переменная типа INT и является значением опции по умолчанию.

OPT_STR - будет добавлено поле для текстового ввода. Аргумент ``value`` рассматривается как переменная типа STR и является значением поля по умолчанию.

#optOption
``` ? optOption (STR name)
Возвращает значение опции с именем ``name``. Тип значения соответствует заданному при объявлении опции.

#optDialog
``` VOID optDialog ()
Показывает пользователю диалог опций. 

== COM Порт ==

#comOpen
``` BOOL comOpen(BAUD,PAR,DATA,STOP)
Открывает порт, возможные варианты параметров:
``` 
BAUD (скорость): BAUD_9600, BAUD_19200, BAUD_115200
PAR (четность): PAR_NONE, PAR_ODD, PAR_EVEN
DATA (биты данных): DATA_5, DATA_6, DATA_7, DATA_8
STOP (стоп биты): STOP_1, STOP_2
``` 
Возвращает 0 если открыть порт не удалось.

#comWrite
``` VOID comWrite(BYTEARRAY data)
Отправляет в порт массив ``data``. Неблокирующая операция.

#comRecived
``` INT comRecived()
Возвращает количество данных в буфере ввода. Неблокирующая операция.

#comRead
``` BYTEARRAY comRead()
Возвращает буфер ввода. Сам буфер очищается. Неблокирующая операция.

#comSetDtr
``` VOID comSetDtr(BOOL mode)
Устанавливает состояние вывода DTR.

#comSetRts
``` VOID comSetRts(BOOL mode)
Устанавливает состояние вывода RTS.

#comSetTimeout
``` VOID comSetTimeout(int time)
Устанавливает Timeout на операции ввода-вывода через COM порт в миллисекундах.

#comClose
``` VOID comClose()
Закрывает порт.



== LPT Порт ==

#lptOpen
``` BOOL lptOpen()
Открывает LPT порт. Возвращает 0 если открыть порт не удалось.

#lptSetMode
``` VOID lptSetMode(MODE)
Переключает пины данных LPT порта межу режимами ввода и вывода: ``OUT`` и ``IN``.

#lptSetData
``` VOID lptSetData(BYTE d)
Устанавливает состояние пинов данных LPT порта.

#lptGetData
``` BYTE lptGetData()
Возвращает значение пинов данных LPT порта.

#lptSetCtr
``` VOID lptSetCtr(BYTE d)
Устанавливает значение пинов управление LPT порта. Все пины рассматриваются как неинвертированные.

#lptGetStat
``` BYTE lptGetStat()
Возвращает значение пинов статуса LPT порта. Все пины рассматриваются как неинвертированные.

#lptClose
``` VOID lptClose()
Закрывает LPT порт.

== I2C Порт ==

C I2C шиной можно работать по средством 2 наборов функций - базового (возможен через любой интерфейс) и рассчитанного на внешний контроллер шины.

#i2cOpen
``` BOOL i2cOpen ()
Открывает I2C интерфейс.

#i2cAskCheck
``` VOID i2cAskCheck (BOOL check)
Прерывать ли операцию в случае NASK.

#i2cIsOk
``` BOOL i2cIsOk ()
Возвращает ``FALSE``, если предыдущая операция была завершена с ошибками.

#i2cClose
``` i2cClose ()
Закрывает I2C интерфейс.

=== Базовое API ===

#i2cWrite
``` VIOD i2cWrite (BYTE adr,BYTEARRAY arr)
Записать в МС по адресу ``adr`` последовательность байт ``arr``.

#i2cRead
``` BYTEARRAY i2cRead (BYTE adr,INT size)
Прочитать из МС по адресу ``adr`` последовательность байт длинной ``size``. Возвращает новый массив с полученными данными.

#i2cWriteRead
``` BYTEARRAY i2cWriteRead (BYTE adr,BYTEARRAY arr,INT size)
Реализует операцию S ARD W "данные из массива arr" S ADR R "прочитать size байт" P. Возвращает новый массив с полученными данными.

=== Ресширенное API ===

*НЕ РЕАЛИЗОВАНО В ДАННОЙ ВЕРСИИ*

#i2cAddWrite
``` VOID i2cAddWrite (BYTE adr,BYTEARRAY arr)
Добавляет в выходной поток операцию S ARD W "данные из массива arr". Неблокирующая операция.

#i2cAddRead
``` VOID i2cAddRead (BYTE adr,INT size)
Добавляет в выходной поток операцию S ARD R "прочитать size байт". Неблокирующая операция.

#i2cAddStop
``` VOID i2cAddStop ()
Добавляет в выходной поток операцию P. Неблокирующая операция.

#i2cAddWait
``` VOID i2cAddWait (INT mmsec)
Добавляет в выходной поток задержку ``mmsec`` микросекунд. Неблокирующая операция.

#i2cPreform
``` BOOL i2cPreform ()
Выполнение всех операций в выходном потоке. Все прочитанный данные записываются последовательно во входной буфер.  Блокирующая операция. Возвращает ``FALSE``, если в ходе выполнения случился NASK.

#i2cGetBuffer
``` BYTEARRAY i2cGetBuffer ()
Возвращает содержимое входного буфера. Буфер при этом очищается.

#i2cGetBufferLength
``` INT i2cGetBufferLength ()
Возвращает количество байт, содержащихся во входном буфере в текущий момент.

== DirectIO Порт ==

Порт DirectIO представляет набор функций для работы с отдельными группами по 8 пинов - портами.

В режиме DirectIO over LPT мы можем работать с тремя портами (0-r/w, 1-ro, 2-wo). Порты соответствуют портам LPT (однако все пины являются неинвертированными).

В режиме DirectIO over FTDI мы можем работать портами количество которых соответствует колличеству портов в подключенной микросхеме. Все порты могут работать в режиме ввода или вывода.

#dioSetPortMode
``` VOID dioSetPortMode (INT port, mode)
Устанавливает режим работы пина с номером ``port``. ``mode`` может принимать значение ``DIO_IN`` - ввод  и ``DIO_OUT`` - вывод.

#dioSetPort
``` VOID dioSetPort (INT port,BYTE val)
Устанавливает пины порта с номером ``port``, в соответствие со значением байта ``val``.

#dioGetPort
``` BYTE dioGetPort (INT port)
Возвращает байт - значения пинов порта, ``port``.

#dioSetPortMode
``` VOID dioSetPortMode (INT port, mode)  
Устанавливает режим работы порта с номером ``port``. ``mode`` может принимать значение ``DIO_IN`` - ввод  и ``DIO_OUT`` - вывод.

== USB Порт ==

*НЕ РЕАЛИЗОВАНО В ДАННОЙ ВЕРСИИ*

#usbOpen
``` BOOL usbOpen (INT vid,INT pid)
Устанавливает соединение с устройством. VID и PID устройства передаются в качестве аргументов.

#usbClose
``` VOID usbClose ()
Закрывает соединение с устройством.

#usbReset
``` VOID usbReset ()
Посылает устройству сигнал сброса.

#usbBulkWrite
``` BOOL usbBulkWrite(BYTEARRAY data)
``` BOOL usbBulkWrite(BYTEARRAY data,INT endpoint)
``` BOOL usbBulkWrite(BYTEARRAY data,INT endpoint,INT timeout)

Выполняет блокирующую запись в устройство. Функция может принимать различное число аргументов. ``data`` - массив данных. который будет записан. ``endpoint`` - номер Endpoint устройства. По умолчанию ``endpoint``=``0``.  ``timeout`` - таймаут операции в миллисекундах, по умолчанию равен 1000 мс.

#usbBulkRead
``` BYTEARRAY usbBulkRead (INT len)
``` BYTEARRAY usbBulkRead (INT len,INT endpoint)
``` BYTEARRAY usbBulkRead (INT len,INT endpoint,INT timeout)

Выполняет блокирующее чтение из устройства и возвращает массив прочитанных байтов. Функция может принимать различное число аргументов. ``len`` - количество байтов, которые нужно прочитать. ``endpoint`` - номер Endpoint устройства. По умолчанию ``endpoint``=``0``.  ``timeout`` - таймаут операции в миллисекундах. по умолчанию равен 1000 мс.

#usbControlMsg
``` VOID usbControlMsg (BYTE cmsgtype,BYTE cmsgrequest)
``` VOID usbControlMsg (BYTE cmsgtype,BYTE cmsgrequest, INT iface)
``` BYTEARRAY usbControlMsg (BYTE cmsgtype,BYTE cmsgrequest, INT iface, INT len)

Выполняет блокирующую передачу управляющей инструкции. Функция может принимать различное число аргументов (от 2 до 4). Аргументы  ``cmsgtype``, ``cmsgrequest`` рассматриваются как тип запроса, собственно запрос. Третий аргумент ``iface`` - номер интерфейса устройства, ``len`` - длина буфера для приема ответа от устройства. Если последний аргумент ``len`` задан, функция возвращает BYTEARRAY, иначе не возвращает значение.




